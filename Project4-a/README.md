## Project 4(a): SM3的软件实现和优化
### SM3实现原理
SM3密码杂凑算法是国家密码管理局于2010年公布的中国商用密码杂凑算法标准，本质是在SHA-256基础上进行改进的一种算法，采用著名的Merkle结构，其消息分组长度选取为512位，这也是本次实践所用的参数。

SM3的实现大致可以分为填充分组、消息扩展、迭代压缩三个部分。

填充分组：将数组长度补足512位后进行分组，填充规则为先填充一个1后加上m个0(m为满足 $(n+1+m) \mod 512=448$ 的最小整数)。之后追加64位的数据长度。此时，我们可以通过分组算法将消息划分为16*32形式。

消息扩展：数据被划分为16个消息字后，通常通过扩展算法将其扩展为132个消息字，这一过程通常通过递推实现，即使用16个字递推出116个字然后合并。

迭代压缩：完成上述步骤后，SM3开始使用消息扩展后的字进行运算。这一过程需要使用八个32位寄存器(一般以A~H命名)，我们将初始向量IV放入寄存器后，调用压缩函数将8个寄存器中的值进行64轮计算(通常以第17轮为界编写两个循环)。

最后将八个寄存器中的值拼接输出，我们就能得到SM3加密后的结果。
### SM3实现代码思路
本任务使用C++完成，代码中已含基本注释，此处说明大体思路。
我们可以将SM3的主要加密过程封装进一个sm3_iter()函数中，使之能一次性包括填充分组，消息扩展和压缩功能。之后将压缩结果和输入的寄存器初始状态异或，即可得到一个中间状态。

完成上述步骤后，构建一个sm3()函数来调用sm3_iter()并完成结果的处理(例如补全，处理剩余块之类)，使结果更加直观。之后main()函数调用上述两个函数就能实现SM3的加密。在计时方面，由于本任务为SM3的简易实现，故计时采用Windows API微秒级计时器，由QueryPerformanceFrequency()系列函数实现。
### 结果呈现
<img width="909" height="164" alt="origin_res" src="https://github.com/user-attachments/assets/71fd1bb9-c359-4430-80ee-c1097b4d1b1e" />

SM3基本实现的测试结果如上，加密所用测试消息为SDUzxj，结果已在第三方SM3加密网站经过测试是正确的。

## SM3优化原理
由于考研任务的存在，我没有过多时间系统性学习SIMD指令集相关知识，故SM3的优化任务只编写了大体的思路，加密结果的正确性没能实现，还望老师或助教见谅！
### 代码思路
由于是在visual studio中使用SIMD指令集，故我们需要在项目属性中设置相应指令集才能进行编译。
<img width="833" height="395" alt="setting" src="https://github.com/user-attachments/assets/00e6e0dc-66ed-4d94-9a09-f91eb5727f03" />

而优化后的SM3流程和之前一致，区别在于现在我们可以通过SIMD指令集进行并行操作，同时更新寄存器状态并进行并行压缩，故此时核心就是将IV的存储转为二维数组，之后引入一个索引结构便于定位即可。

### 结果呈现
由于没有实现正确的加密，故我移除了结果打印的部分，添加了两个cout语句判断函数是否正常进行。
<img width="411" height="271" alt="opti-test" src="https://github.com/user-attachments/assets/05ef1bb4-9b89-4302-be24-28e3856f13ad" />

结果表明加密函数的运行正常，如果优化其中的部分参数和数学计算或许能得到正确的结果。而由最后的运行时间可以看到，并行后的代码运行速度明显加快。



